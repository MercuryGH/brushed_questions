# 用两个栈实现队列

## 暴力做法

其中一个栈$s_1$的出栈序列完全维护成队列的出队序列，另一个栈$s_2$作为辅助。具体方法如下：

### 判空

判断$s_1$是否为空即可。

### 入队

记$s_1$自顶向下为${a_1, \dots, a_k}$，待入队元素为$a_{k+1}$。操作如下：

1. 将$s_1$的栈顶元素依次出栈后压入$s_2$，直到$s_1$为空；
2. 将$s_2$的栈顶元素依次出栈后压入$s_1$，直到$s_2$为空；
3. 将$a_{k+1}$压入$s_1$。

时间复杂度$O(k)$。

### 出队

$\text{pop}(s_1)$即可。

时间复杂度$O(1)$。

### 取队首元素

$\text{top}(s_1)$即可。

## 摊还常数的做法

考虑$s_1$不做特殊操作，入队即压栈$s_1$。

那么，我们如何完成出队操作呢？答案是，一旦需要出队，则将$s_1$的栈顶元素依次出栈后压入$s_2$，直到$s_1$为空，然后弹出$s_2$的栈顶元素即完成出队。接下来的$k$次出队操作，都可以交给$s_2$完成，$s_1$仍然只负责入队。

一旦$s_2$为空且需要出队，$s_1$就继续将它的栈顶元素依次出栈后压入$s_2$，以此循环。

当$s_2$不为空时，容易完成“取队首元素”的操作；而当$s_2$为空时，还需要额外一个变量 `front`保存之。

### 判空

当且仅当$s_1$和$s_2$均为空。

### 入队

如果$s_1$为空，更新 `front`。

压入$s_1$。

### 出队

1. 若$s_2$为空，则将$s_1$的栈顶元素依次出栈后压入$s_2$，直到$s_1$为空；否则什么也不做。
2. 弹出$s_2$的栈顶元素；

### 取队首元素

若$s_2$为空，则返回 `front`，否则返回$s_2$的栈顶元素。

### 摊还常数的证明

其实我们不需要进行摊还分析的证明——直接考虑每个元素，它们必然被push了$2$次，pop了两次，故操作的时间复杂度至多为$O(4) = O(1)$。

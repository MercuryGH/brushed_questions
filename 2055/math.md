# 蜡烛之间的盘子

给定$01$序列$a_n$，接下来进行$m$次查询，每次查询的输入均为一个区间$[l,r], 1 \leq l \leq r \leq n$，记

* $i \geq l$为区间内最小的$i$，满足$a_i=1$；
* $j \leq r$为区间内最大的$j$，满足$a_j = 1$，

若$i < j$，查询的输出应是$ k \in (i,j)$满足$a_k = 0$的$k$的数目。否则，查询的输出是$0$。

请设计一个算法，在非平方时间复杂度下接受$m$次查询。

## 解答

首先，我们可以预处理$a_i$左侧的第一个满足$a_j=1$的$j$，右侧的第一个满足$a_k = 1$的$k$，即左1右1数组 `leftFirst[i], rightFirst[i]`，共花费线性时间复杂度。这样，在询问寻找$i, j$的情况下，只需常数时间复杂度。

然后，我们可以预处理$a_i = 1$时，

$$
\sum_{j=1}^i (a_j = 0)
$$

的值，即前缀和数组 `prefix[i]`，也是花费线性时间复杂度。这样，查询$ k \in (i,j)$满足$a_k = 0$的$k$的数目时，只需给出 `prefix[j] - prefix[i]`即可。

注意特殊情况的处理：如果$a_i$左侧并没有$a_j = 1$的$j$，或者右侧并没有$a_k=1$的$k$，那么记相应的预处理数组的值为$-1$。

预处理时间复杂度$O(n)$，给出$m$个询问的结果只需$O(m)$，故整体时间复杂度为$O(n + m)$。

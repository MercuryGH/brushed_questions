# 目标和

给定序列$a_n$和目标$m$，请给出通过对每个元素$a_i$赋予加号或减号，使得

$$
\sum_{i=1}^n \pm a_i = m
$$

的方案数。如果元素$a_i = 0$，赋予加号或减号同样视为不同方案。

## DP解

记$f_{i,j}$表示只考虑子序列$a_{1:i}$，通过赋予加号或减号得到$\sum_{k=1}^i \pm a_k = j$的方案数。那么状态转移方程为

$$
f_{i,j} = f_{i-1,j-a_i} + f_{i-1, j+a_i}.
$$

初始条件为：

* 若$a_1 \neq 0$，则$f_{1,a_1}=1, f_{1, -a_1} = 1$；
* 若$a_1 = 0$，则$f_{1,a_1} = 2$。

这个状态转移方程与我们通常见到的很不一样。首先我们确定第二维的取值范围。

记$S = \sum_{i=1}^n a_i$，那么$j \in [-S, S]$。于是我们可以确定，对任意$j \notin [-S, S]$，都有$f_{i,j} = 0$。

那么，递推的循环就可以这样写：

```cpp
for (int i = 2; i <= n; i++) {
    for (int j = -S; j <= S; j++) {
        if (j + a[i] > S) {
            f[i][j] = f[i - 1][j - a[i]];
        } else if (j - a[i] < S) {
            f[i][j] = f[i - 1][j + a[i]];
        } else {
            f[i][j] = f[i - 1][j - a[i]] + f[i - 1][j + a[i]];
        }
    }
}
```

最终答案在$f_{n, m}$中。

### 实现细节

如果$m \notin [-S,S]$，直接返回$0$即可。

注意C++的数组下标不能为负数。所以，我们需要将第二维向右平移$S$个单位。

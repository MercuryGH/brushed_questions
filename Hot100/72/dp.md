# 编辑距离

给定两个字符串$s, t$，你可以对$s$或$t$进行如下三种操作：

1. 插入一个字符；
2. 替换一个字符；
3. 删除一个字符。

请给出使$s = t$的最小操作数。

## 引理

容易证明：

1. “对$s$删除一个字符”和“对$t$插入一个字符”，在对减小编辑距离的含义上等价。同理，对$s$插入也与对$t$删除等价。
2. “对$s$替换一个字符”和“对$t$替换一个字符”，在对减小编辑距离的含义上等价。

因此，我们不妨将能做的操作缩小为：

1. 对$s$插入一个字符；
2. 对$t$插入一个字符；
3. 对$s$替换一个字符。

## DP解

记$f_{i,j}$为只考虑$s_{1:i}$，$t_{1:j}$的编辑距离。考虑状态转移：

1. $f_{i,j-1}$转移到$f_{i,j}$，只需在$t_{1:j-1}$的末尾插入一个$s_i$即可。故$f_{i,j} = f_{i,j-1} + 1$。
2. $f_{i-1,j}$转移到$f_{i,j}$，只需在$s_{1:i-1}$的末尾插入一个$t_j$即可。故$f_{i,j} = f_{i-1,j} + 1$。
3. $f_{i-1,j-1}$转移到$f_{i,j}$，若
   * $s_i = t_j$，不需要做任何编辑，$f_{i,j} = f_{i-1,j-1}$；
   * $s_i \neq t_j$，只需替换$s_i$使之变为$t_j$，故$f_{i,j} = f_{i-1,j-1} + 1$。

$f_{i,j}$不能从其他状态转移而来了。故状态转移方程为：

$$
f_{i, j} = 
\begin{cases}
\min(f_{i, j -1} + 1, f_{i-1,j} + 1, f_{i-1,j-1}), & s_i = t_j, \\
\min(f_{i, j -1} + 1, f_{i-1,j} + 1, f_{i-1,j-1} + 1), & s_i \neq t_j,
\end{cases}
$$

初值条件为$f_{i,0}= i, f_{0,j}=j$。

（空间复杂度可优化为$O(\min(n,m))$）。

# DP之序列配对问题

给定长度为$m,n$的两个DNA序列$g,h$，其元素只可能取$\{A,T,C,G\}$。这两个序列中，位置为$i$的两个元素互相匹配。

下面给出一个$m=5,n=4$的例子。

$$
\begin{aligned}
g &= AGCCT, \\
h &= ACCG.
\end{aligned}
$$

此时，位置为$0$的$A$与$A$匹配，位置为$1$的$G$与$C$匹配，位置为$2$的$C$与$C$匹配，位置为$3$的$C$与$C$匹配，位置为$4$的$T$与$\_$匹配。

我们可以在DNA序列中插入任意数目的$\_$作为空格。例如，在$h$的位置$2$前插入一个$\_$，可以得到

$$
h' = AC\_CG,
$$

显然，这使得两个序列的匹配方式发生了变化。

因此，对于任意两个DNA序列，配对的方式多种多样。我们给出如下的打分规则：

1. 如果字母和字母进行配对，且进行配对的两个字母相同，则分数$+1$。
2. 如果字母和字母进行配对，但进行配对的两个字母不同，则分数$-1$。
3. 如果配对的对象中有空格$\_$，则分数$-1$。

例如，对于$g,h$的匹配，分数为$1-1+1+1-1 = 1$；对于$g,h'$的匹配，分数为$1-1-1+1-1=-1$。

对于给定长度为$m,n$的两个DNA序列$g,h$，请找出得分最高的匹配方式，输出其得分即可。

## 解答

定义$f_{i,j}$表示只考虑$g$的前$i$个元素，$h$的前$j$个元素时，所能得到的最高分。答案在$f_{m,n}$。

由于可以任意添加空格，我们可以把匹配过程看成始终是等长的两个序列进行匹配。有三种状态转移到达$f_{i,j}$：

1. $f_{i,j}$中，$g$的第$i$个元素是添加的空格，$h$的第$j$个元素是$h$原本就有的字母；
2. $f_{i,j}$中，$g$的第$i$个元素是$g$原本就有的字母，$h$的第$j$个元素是添加的空格；
3. $f_{i,j}$中，$g$的第$i$个元素是$g$原本就有的字母，$h$的第$j$个元素是$h$原本就有的字母。

注意不会出现$g$的第$i$个元素和$h$的第$j$个元素都是空格的情况，因为这种情况只会降低分数，完全可以剪枝。

三种情况的状态转移方程分别为

$$
f_{i,j} = f_{i-1,j} - 1, \tag{1}
$$

$$
f_{i,j} = f_{i,j-1} - 1, \tag{2}
$$

$$
f_{i,j} =
\begin{cases}
 f_{i-1,j-1} + 1, g_{i} = h_j \\ - 1, g_i \neq h_j. \tag{3}
\end{cases}
$$

于是，最终DP公式为三者的最大值：

$$
f_{i,j} = \max((1),(2),(3)).
$$

初值条件为$f_{-1,-1} = 0,f_{-1,0}=0, f_{0,-1}=0$. （$f_{0,0}$也要用公式计算）。

可以进行状态压缩。

# 最大子列积

由于两个间隔很远的负数的乘积可以是很大的正数，所以不能套最大子列和的DP方程。

记状态$S_i$为只考虑原始序列的前$i$个元素。考虑从状态$S_{i-1}$转移到$S_i$，对$a_i$分类讨论：

* 若$a_i > 0$，则预计可以更新最大子列积。
* 若$a_i < 0$，我们考虑之前可能存在的另一个负元素$a_j (j < i)$，如果我们有一个“最小子列积”DP数组，就可以负负得正，并与最大子列积中的结果相比较，可能得到更新答案的机会。
* 若$a_i = 0$，则乘上它很浪费，取个max吧。

因此，记$f_i$表示只考虑原始序列的前$i$个元素，得到的最大子列积；$g_i$表示只考虑原始序列的前$i$个元素，得到的最小子列积，则状态转移方程为：

$$
f_{i} = \begin{cases}
\max(f_{i - 1} \cdot a_i, a_i), &a_i \geq 0 \wedge f_{i - 1} > 0  \\
g_{i - 1} \cdot a_i , &a_i < 0 \wedge g_{i - 1} < 0 \\
\end{cases}.
\\
g_{i} = \begin{cases}
\min(g_{i - 1} \cdot a_i,a_i), &a_i \geq 0\wedge g_{i - 1} < 0   \\
f_{i - 1} \cdot a_i , &a_i < 0 \wedge f_{i - 1} > 0 \\

\end{cases}.
$$

初始条件为$f_1 = a_1, g_1 = a_1$。容易知道，将状态转移方程简化成

$$
f_i = \max(f_{i - 1} \cdot a_i, g_{i - 1} \cdot a_i, a_i), \\
g_i = \min(g_{i - 1} \cdot a_i, f_{i - 1} \cdot a_i, a_i), \\
$$

不会错过存放在$f_n$中的结果。由于$f_i, g_i$均只与前一个元素有关，因此可以用滚动数组优化空间。

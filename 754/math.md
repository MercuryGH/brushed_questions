# 步子迈得越来越大的左右横跳

给定非零整数$n$，你需要找出长度尽可能小的$\{-1,+1\}$序列$a_m$，满足

$$
a_1 + 2a_2 + 3a_3 + \dots + ma_m = n.
$$

输出最小的$m$。

## 例子

$n = 2$，则$a_m = \{1, -1, 1\}$，有$1-2+3 = n$。故输出$m=3$。

## 解答

搜索太暴力了。

由对称性，$n$和$-n$所对应的序列$a_m$只需将所有元素取反即可，故我们只需考虑正数$n$。

对于正数$n$，我们先考虑贪心地向右接近，即考虑最小化$m$，使得

$$
1 + 2 + \dots + m = \frac{m(m+1)}{2} \geq n.
$$

若等式成立，则得到答案；但若等式不成立，我们记$S_m = 1 + \dots + m$，考虑

$$
S_m - n
$$

的值。显然该值必然是一个位于$[1, m]$的正整数。

我们发现，只需让之前的累加式中的若干个加号反向成减号，且被反向的项的系数之和恰好为$\frac{S_m-n}{2}$，那么等式就能成立。于是我们得到了答案！

接下来我们证明以下定理：

1. 当$S_m - n$为偶数时，一定**能**找到这些系数，它们的和恰好为$\frac{S_m-n}{2}$。

**证明**

显然$\frac{S_m - n}{2} \in [1, \frac{m}{2}]$，在$[1,m]$中直接选出一个数恰好等于它即可。证毕。

2. 当$S_m - n$为奇数时，一定**不能**找到这些系数，它们的和恰好为$\frac{S_m-n}{2}$。

**证明**

显然的。奇数不能被$2$整除。

---

那么，奇数如何处理？只好考虑$m+1, m+2$，然后考虑$S_{m+1} - n$和$S_{m+2}-n$。这两个结果中，必然有一个结果是偶数，从而找到答案。（一定能够找到系数的证明与前文略有不同，此处省略）

由于我们只需输出$m$，故本题等价于最小化$m$，使得

$$
(S_m -n) \bmod 2 = 0 \wedge S_m \geq n
$$

从$1$到$n$枚举$m$可解。时间复杂度为$O(\sqrt n)$；或者，直接解一个一元二次方程，时间复杂度与 `sqrt()`的时间复杂度相同（一般可以认为 `sqrt()`是常数时间复杂度的，x86-64的FPU直接支持 `sqrt()`指令的计算）。

```cpp
int reachNumber(int target)
{
    if (target < 0)
    {
        target = -target;
    }

    int sum = 0;
    for (int i = 1; ; i++)
    {
        sum += i;
        if (sum >= target)
        {
            if ((sum - target) % 2 == 0)
            {
                return i;
            }
        }
    }

    return -1;
}
```

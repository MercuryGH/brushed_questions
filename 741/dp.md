# 摘樱桃

给定$n \times m$棋盘$a_{n-1,m-1}$，其中的格点可取值为$\{-1,0,1\}$。其中：

* 值为$-1$的表示为障碍；
* $0$表示为空地；
* $1$表示为樱桃。

玩家从$(0,0)$出发，通过若干次向下或向右移动一格到达$(n-1,m-1)$，然后从$(n-1,m-1)$，通过若干次向上或向左移动一格返回。在限制不能移动到障碍格的情况下，请输出能够摘到樱桃的最大数目。如果障碍导致无法从$(0,0)$移动到$(n-1,m-1)$，输出$0$。

请注意：重复移动到同一樱桃格，不会重复计数。

## DP解

注意到返程与再去一趟是等价的。

设$f_{p,q}$为从点$(0,0)$出发到达点$p$，然后再从点$(0,0)$出发到达点$q$，所能摘到樱桃的最大数目。那么答案在$f_{(n-1,m-1),(n-1,m-1)}$

尝试写出状态转移方程：由于一定是从左侧或上侧的点到达当前点，故可记$\text{adj}(p)$表示$p$点左侧和上侧的邻近点组成的集合，那么

$$
f_{p,q} = \max_{p' \in \text{adj}(p), q' \in \text{adj}(q)}(f_{p',q'}) + a_{p} + a_q.
$$

其中的$\max()$内部一般有$4$个元素（若越界，则可能少于$4$个元素）。需要注意的是，如果$p = q$，那么同一块樱桃地被走了两次，因此不能重复加和，状态转移方程变为

$$
f_{p,q} = \max_{p' \in \text{adj}(p), q' \in \text{adj}(q)}(f_{p',q'}) + a_{p}.
$$

### 边界条件

$f_{(0,0),(0,0)} = a_{0,0}$。

**特判**：由于不允许经过障碍，故所有包含障碍点$p$的$f_{p,q} = -\infty$，同理，所有越界点$p$的$f_{p,q} = -\infty$，避免错误地更新DP答案。在初始化DP数组时，也要默认所有点（除了起点）都处于不可达状态，即$f_{p,q} = -\infty$。如果最终答案就是$-\infty$，则要输出$0$。

使用C/C++实现时，小心数组下标越界。

### DP 优化

很明显这个DP是四维的，时空复杂度均为$O(n^2m^2)$，非常可怕。

对于$p = (i,j), q= (k,l)$，它们分别对应第一次出发和第二次出发所到达的点。如果我们考虑**同时出发**，那么答案应该与先后出发是一样的，但是这样就始终有

$$
i + j = k + l
$$

成立。不妨记$s = i + j$，那么在同时出发的情况下，状态$(p,q)$只需要三个整数$(s, i, k)$，或等价地，$(i,j,k)$就能完全确定，进而优化一维时空复杂度。

尽管这个思路是完全正确的，但代码实现是有难度的，还需要考虑不少边界条件，因此算了。
